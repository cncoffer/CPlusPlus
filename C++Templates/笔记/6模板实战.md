# 6.1 包含模型 #

如果将template 函数/类的声明放在.h中, 定义放在.cpp中, 那么在link时会报错.
原因是这样的: 当编译器看到template的调用时, 可能还没有看到其基于某一个类型实例化的定义, 这是他假设在别处提供了这个定义, 并产生一个指向改定义的引用(让链接器利用该引用来解决这一问题). 而另一方面, 当编译器处理template的调用时, 他并没有指出: 编译器必须基于特定实参对所包含的模板定义进行实例化. 所以链接器肯定找不到这一实例化的定义.

而如果将template的声明和定义都放在.h中, 然后用到的地方包含这一.h文件, 就不会报错.

但是这样也带来了问题, 大大增加了编译复杂程序所耗费的时间.

# 6.2 显式实例化 #

在代码中将template手工实例化, 就能确保link的时候不会报错.
在用到的地方包含模板的声明, 然后手工实例化的例子:
    // templatefile.h
    template <typename T>
    void fun(T const& n);

    // main.cpp, 实例化一个int类型的函数
    #include "templatetest.cpp"
    template void fun<int>(int const&);

需要注意, 每个程序中, 相同的实例化体只能有一个, 也就是说上面的fun()函数, 我们只能手工实例化一次int类型.
如果在多处实例化int类型, 会导致链接错误.

到此, 我们发现显式实例化有一个致命缺点, 在大型工程中手工实例化需要人为的跟踪, 保证只能实例化一次.
不过好处也有, 对比包含模型, 可以减少开销, 并且只在需要的地方实例化.

结合包含模型和显式实例化的做法:
仍然将声明和定义放在两个问题, 然后声明的文件命名为stack.h, 定义的文件命名为stackdef.h(并且它肯定包含stack.h), 
如果希望使用包含模型, 就在代码中include头文件`stackdef.h`, 如果希望使用显式实例化, 就包含头文件`stack.h`然后手工实例化.

# 6.3 分离模型 #

对template使用export关键字.
虽然这是C++的标准, 但其实几乎没有编译器支持. 略过即可.

