### 18 并发 ###

### 18.1 高级接口: async()和future ###

看了这一章, 才发现我对于并发的理解还局限在多线程上, 但并发并不仅仅是创建多线程, 比如可以使用async()来实现并发.

他的实现在<future>中.

用起来很简单, 创建一个future对象保存结果, 然后使用async运行函数.
	future<int> ret1(async(fun1));
	int ret2 = fun2();
	int result = ret1.get() + ret2;

对于支持并行的环境就会并发进行, 对于不支持或者线程不够的环境, 就会顺序执行.
也就是说能够让程序在并行环境收益, 在单线程环境也正确运行.

但要注意的是, 上面的正确性只在不存在数据竞争的情况下保证.

另外, ret1.get()是需要等待async运行结束的, 也就是说这一调用应该在不得不用到的地方调用, 否则并行的收益就会下降. 也就是早调用而晚返回, 能够保证收益最大化.

async可以接受任何类型的callable object, 也就是说能够将lambda放在线程中运行, 听起来很不错不是吗.

然后, 对于async可以指定std::launch::async, std::launch::deferred, 分别表示强制立即执行和强制延迟执行.
于是使用deferred可以写出下面这样的代码:
	auto f1 = std::async(std::launch::deferred, task1);
	auto f2 = std::async(std::launch::deferred, task2);
	// do something
	auto val = thisOrTharIsTheCase() ? f1.get() : f2.get();

虽然和在用到的时候执行task1和task2性能上好像没什么区别...
不过在优化代码结构上会非常有用.

在异常上, async和正常的调用没有区别, 就像以前那样捕获异常即可.

- 等待
使用wait()可以强制启动future的线程并等待这一后台操作终止, 要获取他的结果还是用get().
使用wait_for(一个时间段), wait_until(time_point), 都可以等待一段时间, 然后返回future的状态, 会有三种状态
1. std::future_status::deferred		表示延缓操作, 而又没有调用wait()或get()来启动.
2. std::future_status::timeout		表示操作启动但是尚未结束, 并且waiting逾期.
3. std::future_status::ready		表示操作已完成.

使用wait_for和wait_until可以写出所谓的投机性运行. 进行一个复杂的计算和一个简单的计算, 如果到时间点了复杂的计算有结果就返回复杂的计算结果, 否则就返回简单的计算结果.
这种做法听起来非常酷, 有机会可以用用. 比如获取帧.


### 18.1.3 shared future ###

future只能get()一次, 而shared_future可以get()多次, 如果抛出异常也是在get()时抛出同样的异常多次.

### 18.2 低层接口: thread和promise ###

声明一个std::thread对象, 将目标任务当做初识实参, 然后要么等待他结束.join(), 要么将它卸离.detach().

高层接口async包装的更好一些, 接口和功能也丰富一些, 但是不保证是并行的.
低层接口thread是强制并行执行的, 但是接口和功能会少一些, 如果无法并行会抛出异常.

要当心detached thread.
因为这些线程如果使用的非local资源, 比如by reference传入的参数, 比如global和static object, 当程序结束时, detached thread可能还在运行, 那他就有可能访问已被销毁或正在析构的object.

threadID是唯一的, 只能用来比较和输出到stream, 然后他有可能在被申请的时候才动态分配, 所以id为多少并不意味着什么.

### 18.2.3 class packaged_task<> ###

可以把目标函数及其可能结果放在packaged_task<>中, 然后在需要的时候调用他.
有点绕, 但书中也没有给非常详细的例子, 用到的时候再查吧.

### 18.4 线程同步化与Concurrency问题 ###

并发访问会存在很多问题, 本小节先了解问题所在, 然后后面的章节再介绍解决办法.
C++11保证每个变量都拥有自己的内存区, 也就是说并发处理不同的的变量或对象或成员, 不会有问题.

